from typing import override

import jsonschema
from PIL import Image

from core import Context, Operation, XoppExportFactory

from operations.registry import register_operation

@register_operation("load")
class LoadOperation(Operation):
    def __init__(self, config: dict):
        super().__init__(config)

        self.paper_background_preserved: bool = config.get("paper_background_preserved", False)
        self.pdf_background_transparent: bool = config.get("pdf_background_transparent", False)

        sub_config: bool = ("trim_directions" in config) and any(config["trim_directions"])
        self.trim: bool = config.get("trim", sub_config)

        self.trim_directions: list[bool] = config.get("trim_directions", [True, True, True, True])
        self.trim_paddings: list[int] = config.get("trim_paddings", [0, 0, 0, 0])
    
    @override
    def validate(self, config: dict) -> None:
        CONFIG_SCHEMA = {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "type": "object",
            "additionalProperties": False,
            "properties": {
                "paper_background_preserved": { "type": "boolean" },
                "pdf_background_transparent": { "type": "boolean" },
                "trim": { "type": "boolean" },
                "trim_directions": { "type": "array",
                    "items": [
                        { "type": "boolean" },
                        { "type": "boolean" },
                        { "type": "boolean" },
                        { "type": "boolean" }
                    ]
                },
                "trim_paddings": { "type": "array",
                    "items": [
                        { "type": "integer" },
                        { "type": "integer" },
                        { "type": "integer" },
                        { "type": "integer" }
                    ]
                }
            }
        }

        jsonschema.validate(config, CONFIG_SCHEMA)

    @override
    def operate(self, context: Context) -> Context:
        images = XoppExportFactory.get_xopp_export(
            context.xopp_file_path,
            self.paper_background_preserved,
            self.pdf_background_transparent,
            context.page_count,
            context.annotation_pdf_path is not None
        )

        # If we want to trim empty margins, we need to do it at the beginning operation (LoadOperation) in pipeline
        # because images generated by Xournalpp command line tool could have non-transparent paper background
        # in that case, it's hard and time consuming to determine the boundary of empty margins.
        if self.trim:
            locator_images = XoppExportFactory.get_xopp_export(
                context.xopp_file_path,
                False,
                True,
                context.page_count,
                context.annotation_pdf_path is not None
            )

            images = self._trim_batch(images, locator_images)

        context.output_images = images
        
        return context

    def _trim_batch(self, base_images: list[Image.Image], locator_images: list[Image.Image]) -> list[Image.Image]:
        images = []
        
        for i in range(len(base_images)):
            trimmed_image = self._trim(base_images[i], locator_images[i])
            if trimmed_image is not None:
                images.append(trimmed_image)
        
        return images
    
    def _trim(self, base_image: Image.Image, locator_image: Image.Image) -> Image.Image | None:
        """ Trim the empty margins of the base image based on the locator image.

        Args:
            base_image (PIL.Image.Image): The base image to be trimmed.
            locator_image (PIL.Image.Image): The locator image used to determine the trimming boundaries.

        Returns:
            PIL.Image.Image: The trimmed image if successful.
            None: If the image is all transparent or the paddings are too negative.

        """
        (width, height) = base_image.size
        bbox = locator_image.getbbox()  # if image is all transparent, bbox would be None

        if bbox is None:
            return None

        (left, top, right, bottom) = (0, 0, width, height)
        (left_boundary, top_boundary, right_boundary, bottom_boundary) = bbox

        if self.trim_directions[0]:
            left = max(left, left_boundary - self.trim_paddings[0])

        if self.trim_directions[1]:
            top = max(top, top_boundary - self.trim_paddings[1])

        if self.trim_directions[2]:
            right = min(right, right_boundary + self.trim_paddings[2])

        if self.trim_directions[3]:
            bottom = min(bottom, bottom_boundary + self.trim_paddings[3])

        if left >= right or top >= bottom:
            return None

        trimmed_image = base_image.crop((left, top, right, bottom))

        return trimmed_image
