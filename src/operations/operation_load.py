from typing import override

import jsonschema
from PIL import Image

from core import Context, Operation, XoppExportFactory

from operations.registry import register_operation

@register_operation("load")
class LoadOperation(Operation):
    def __init__(self, config: dict):
        super().__init__(config)

        self.paper_background_preserved: bool = config.get("paper_background_preserved", False)
        self.transparent_pdf_background: bool = config.get("transparent_pdf_background", False)

        sub_config: bool = ("direction_enabled" in config) and any(config["direction_enabled"])
        self.crop_empty_margins: bool = config.get("crop_empty_margins", sub_config)

        self.direction_enabled: list[bool] = config.get("direction_enabled", [True, True, True, True])
        self.paddings: list[int] = config.get("paddings", [0, 0, 0, 0])
    
    @override
    def validate(self, config: dict) -> None:
        CONFIG_SCHEMA = {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "type": "object",
            "additionalProperties": False,
            "properties": {
                "paper_background_preserved": { "type": "boolean" },
                "transparent_pdf_background": { "type": "boolean" },
                "crop_empty_margins": { "type": "boolean" },
                "direction_enabled": { "type": "array",
                    "items": [
                        { "type": "boolean" },
                        { "type": "boolean" },
                        { "type": "boolean" },
                        { "type": "boolean" }
                    ]
                },
                "paddings": { "type": "array",
                    "items": [
                        { "type": "integer" },
                        { "type": "integer" },
                        { "type": "integer" },
                        { "type": "integer" }
                    ]
                }
            }
        }

        jsonschema.validate(config, CONFIG_SCHEMA)

    @override
    def operate(self, context: Context) -> Context:
        images = XoppExportFactory.get_xopp_export(
            context.xopp_file_path,
            self.paper_background_preserved,
            self.transparent_pdf_background,
            context.page_count,
            context.annotation_pdf_path is not None
        )

        # If we want to crop empty margins, we need to do it at the beginning operation (LoadOperation) in pipeline, because images generated by Xournalpp command line tool could have non-transparent paper background, in that case, it's hard and time consuming to determine the boundary of empty margins.
        if self.crop_empty_margins:
            locator_images = XoppExportFactory.get_xopp_export(
                context.xopp_file_path,
                False,
                True,
                context.page_count,
                context.annotation_pdf_path is not None
            )

            images = self._crop_empty_margins_batch(images, locator_images)

        context.output_images = images
        
        return context

    def _crop_empty_margins_batch(self, base_images: list[Image.Image], locator_images: list[Image.Image]) -> list[Image.Image]:
        images = []
        
        for i in range(len(base_images)):
            cropped_image = self._crop_empty_margins(base_images[i], locator_images[i])
            if cropped_image is not None:
                images.append(cropped_image)
        
        return images
    
    def _crop_empty_margins(self, base_image: Image.Image, locator_image: Image.Image) -> Image.Image | None:
        """ Crop the empty margins of the base image based on the locator image.

        Args:
            base_image (PIL.Image.Image): The base image to be cropped.
            locator_image (PIL.Image.Image): The locator image used to determine the cropping boundaries.

        Returns:
            PIL.Image.Image: The cropped image if successful.
            None: If the image is all transparent or the paddings are too negative.

        """
        (width, height) = base_image.size
        bbox = locator_image.getbbox()  # if image is all transparent, bbox would be None

        if bbox is None:
            return None

        (left, top, right, bottom) = (0, 0, width, height)
        (left_boundary, top_boundary, right_boundary, bottom_boundary) = bbox

        if self.direction_enabled[0]:
            left = max(left, left_boundary - self.paddings[0])

        if self.direction_enabled[1]:
            top = max(top, top_boundary - self.paddings[1])

        if self.direction_enabled[2]:
            right = min(right, right_boundary + self.paddings[2])

        if self.direction_enabled[3]:
            bottom = min(bottom, bottom_boundary + self.paddings[3])

        if left >= right or top >= bottom:
            return None

        cropped_image = base_image.crop((left, top, right, bottom))

        return cropped_image
